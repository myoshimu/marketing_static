---
title: "Model Test"
output: html_notebook
---

相互相関とはラグをみて、、、
マツダ：ハイパーパラメータを確認

```{r}
#前処理
library(dlm)
library(dplyr)
par(mfrow=c(1,1)) 

query<-read.csv("mazda/daily.csv",sep="\t")
grp<-read.csv("mazda/grp.csv")
```

  
### 単純に日別視聴率で回帰
観測モデル

$$y_t=x^0_t\beta_0,_t + x^1_t\beta_1,_t + e_t ~~~~~e_t\sim N(0,\sigma^2) \\
=(x^0_t,x^1_t)(\beta_0,_t,\beta_1)^t + e_t \\
=H_t\beta_t + e_t$$
  
平滑化事前分布により上記のβを以下のようにモデル化する

$$\beta_{0,t} = \beta_{0,t-1}+v^0_t, ~~~~v^0_t\sim N(0,\tau^2_0) \\
\beta_{1,t} = \beta_{1,t-1}+v^1_t, ~~~~v^1_t\sim N(0,\tau^2_1) \\$$
  
上記をベクトル表現すると、以下システムモデルの式が得られる。

$$\beta_t=F_t\beta_{t-1}+G_t v_t \\
\left[
  \begin{array}{c}
  \beta_{0,t} \\\beta_{1,t} 
  \end{array}
  \right]
=
  \left[
    \begin{array}{cc}
    1&0 \\0&1
    \end{array}
    \right]
\left[
  \begin{array}{c}
  \beta_{0,t-1} \\\beta_{1,t-1} 
  \end{array}
  \right]
+
  \left[
    \begin{array}{cc}
    1&0 \\0&1
    \end{array}
    \right]
\left[
  \begin{array}{c}
  v^0_t \\v^1_t 
  \end{array}
  \right]$$
  
```{r}

# 検索数前処理
q <- query %>%
  dplyr::select(StartDate,Queries) %>%
  dplyr::group_by(date=as.Date(StartDate)) %>%
  dplyr::summarise(query = sum(Queries))

# 視聴数を単純に日別集計
g<- grp %>%
  dplyr::select(date,person) %>%
  dplyr::group_by(date=as.Date(date)) %>%
  dplyr::summarise(grp = sum(person))
g[is.na(g)]<-0

#視聴率と検索を結合
d <- dplyr::inner_join(q,g,by="date")

y<-log(d$query)
x<-log(d$grp) #CM視聴数＝説明変数

```
もっとも単純なモデル。fit.1$valueは最大対数尤度。

$$AIC=-2\times対数尤度+2\timesパラメータ数$$

```{r}

#dVは観測モデルの分散。dWはシステムモデル(事変)の切片と回帰係数の分散。
build.1 <- function(params){
  dlmModReg(x, dV = exp(params[1]), dW = exp(params[2:3]))
}

fit.1 <- dlmMLE(y,rep(0,3),build.1)
-2*fit.1$value+2*3
```


exp(fit1.$par)は推定された分散、sqrtして標準偏差求める

```{r}
sqrt(exp(fit.1$par))
```

左から順番に、観測誤差、過程誤差1、2の標準偏差。

```{r}
mod1 <- build.1(fit.1$par) #さらに推定された値をパラメータとして入力
mod1$JFF
mod1$FF
head(mod1$X)
```

JFF：「説明変数がどこに入るか」を表した行列。2列目が「1」なので、FFの2列目に1番目の説明変数が入る。  
X：説明変数。1行目がFFに入る。時間tにおいて、Xのt行目の値が入る。

```{r}
filt1<-dlmFilter(y,mod1) # Apply Kalman Filter
smooth1 <- dlmSmooth(filt1) # Smoothing

#filt1$m #フィルタリングされた切片？
a1<-dropFirst(smooth1$s[,1]) #平滑化された切片
a2<-dropFirst(smooth1$s[,2]) #回帰係数（CM効果）
estimatedLevel <- a1+x*a2

#　元データ
plot(y, col="gray", type="l", main="query", xlab="day")
 
lines(estimatedLevel, col=4) # 推定された状態
# 凡例
legend("topleft", legend=c("Smoothed"), lty=1, col=c(4))

```

###Networkごとに視聴率集計

観測モデル

$$
  \begin{equation}
y_t=x^0_t\beta_{0,t} + x^1_t\beta_{1,t} + ... + x^5_t\beta_{0,t} + e_t ~~~~~e_t\sim N(0,\sigma^2) \\
=(x^0_t,x^1_t,x^2_t,x^3_t,x^5_t)(\beta_{0,t},\beta_{1,t},\beta_{2,t},\beta_{3,t},\beta_{4,t},\beta_{5,t})^t + e_t \\
=H_t\beta_t + e_t
\end{equation}
$$
  
  平滑化事前分布により上記のβを以下のようにモデル化する

$$\beta_{0,t} = \beta_{0,t-1}+v^0_t, ~~~~v^0_t\sim N(0,\tau^2_0) \\
\beta_{1,t} = \beta_{1,t-1}+v^1_t, ~~~~v^1_t\sim N(0,\tau^2_1) \\
\beta_{2,t} = \beta_{2,t-1}+v^2_t, ~~~~v^2_t\sim N(0,\tau^2_2) \\
\beta_{3,t} = \beta_{3,t-1}+v^3_t, ~~~~v^3_t\sim N(0,\tau^2_3) \\
\beta_{4,t} = \beta_{4,t-1}+v^4_t, ~~~~v^4_t\sim N(0,\tau^2_4) \\
\beta_{5,t} = \beta_{5,t-1}+v^5_t, ~~~~v^5_t\sim N(0,\tau^2_5) \\$$
  上記をベクトル表現すると、以下システムモデルの式が得られる。
$$\beta_t=F_t\beta_{t-1}+G_t v_t \\
\left[
  \begin{array}{c}
  \beta_{0,t} \\\beta_{1,t}\\...\\\beta_{5,t} 
  \end{array}
  \right]
=
  \left[
    \begin{array}{cccc}
    1&0&0&0&0 \\0&1&0&0&0\\0&0&1&0&0\\0&0&0&1&0\\0&0&0&0&1
    \end{array}
    \right]
\left[
  \begin{array}{c}
  \beta_{0,t-1} \\\beta_{1,t-1}\\...\\\beta_{5,t-1} 
  \end{array}
  \right]
+
  \left[
    \begin{array}{ccccc}
    1&0&0&0&0 \\0&1&0&0&0\\0&0&1&0&0\\0&0&0&1&0\\0&0&0&0&1
    \end{array}
    \right]
\left[
  \begin{array}{c}
  v^0_t \\v^1_t\\...\\v^5_t 
  \end{array}
  \right]$$
  
```{r}
g<- grp %>%
  dplyr::select(date,network,person) %>%
  dplyr::group_by(date=as.Date(date),network) %>%
  dplyr::summarise(grp = sum(person)) %>%
  tidyr::spread(key = network, value = grp)

g[is.na(g)]<-0
#視聴率と検索を結合
d <- dplyr::inner_join(q,g,by="date")
y<-log(d$query)
x1<-sqrt(d$CX)
x2<-sqrt(d$EX)
x3<-sqrt(d$NTV)
x4<-sqrt(d$TBS)
x5<-sqrt(d$TX)
vars<-cbind(x1,x2,x3,x4,x5)

build.2 <- function(params){
  # exp(param[1])の対数変換した空間で線形探索（山登り方で負の値もとらせるため）
  # システムノイズのxごとの傾き5個＋切片＋観測ノイズの分散でパラメータ数全部で7個
  dlmModReg(vars,dV = exp(params[1]), dW = exp(params[2:7]))
}

#デフォルトでマイナスから＋無限大に設定されてるのでupper,lowerで各パラメータの上限指定
#log(0.000001),log(0.1)を指定するとエラーになるので直接-13,-2を指定
fit.2<-dlmMLE(y,rep(0,7),build.2
              ,lower = c(rep(-30,7))
              ,upper = c(rep(0,7)) ,hessian=T
              ,control = list(maxit = 1000,trace=1))

fit.2$convergence
```

```{r}
# Estimated variance
fit.2$par
exp(fit.2$par)
fit.2$value 
```

```{r}
# Build model using the estimated var
mod2 <- build.2(fit.2$par)
filt2<-dlmFilter(y,mod2)
smooth2 <- dlmSmooth(filt2)

par(mfrow=c(2,3))
a0<-dropFirst(smooth2$s[,1])
a1<-dropFirst(smooth2$s[,2]) #CX
a2<-dropFirst(smooth2$s[,3]) #EX
a3<-dropFirst(smooth2$s[,4]) #NTV
a4<-dropFirst(smooth2$s[,5]) #TBS
a5<-dropFirst(smooth2$s[,6]) #TX
estimatedLevel <- a0+x1*a1+x2*a2+x3*a3+x4*a4+x5*a5
plot(y, type="l", col=8, ylab="", main="Filtered Result")
lines(filt2$f,type="l",col=2)
lines(estimatedLevel,type="l",col=4)
par(mfrow=c(2,3)) 
plot(a1,type="l",xlab="days",ylab="beta_0" )
plot(a2,type="l",xlab="days",ylab="beta_1")
plot(a3,type="l",xlab="days",ylab="beta_2")
plot(a4,type="l",xlab="days",ylab="beta_3")
plot(a5,type="l",xlab="days",ylab="beta_4")
plot(a6,type="l",xlab="days",ylab="beta_5")

```

```{r}
#相互相関をみるとLag0,1で0.6近くあり極めて相関が高い
ccf(x2,x3)
```

##時間帯ごとのモデル

```{r}
grp$time<-gsub("(10|11|12|13|14)", "Noon", grp$time)
grp$time<-gsub("(15|16|17|18)", "Evening", grp$time)
grp$time<-gsub("(19|20|21|22|23)", "Prime", grp$time) 
grp$time<-gsub("(24|25|26|27|28|[1-5])", "Midnight", grp$time)
grp$time<-gsub("([6-9])", "Morning", grp$time)
g<- grp %>%
  dplyr::select(date,time,person) %>%
  dplyr::group_by(date=as.Date(date),time) %>%
  dplyr::summarise(grp = sum(person)) %>%
  tidyr::spread(key = time, value = grp)
g[is.na(g)]<-0

#視聴率と検索を結合
d <- dplyr::inner_join(q,g,by="date")
y<-log(d$query)
x1<-log(d$Morning+1)
x2<-log(d$Noon+1)
x3<-log(d$Evening+1)
x4<-log(d$Prime+1)
x5<-log(d$Midnight+1)
vars<-cbind(x1,x2,x3,x4,x5)

build.3 <- function(params){
  # exp(param[1])の対数変換した空間で線形探索（山登り方で負の値もとらせるため）
  dlmModReg(vars,dV = exp(params[1]), dW = exp(params[2:7]))
}

#デフォルトでマイナスから＋無限大に設定されてるのでupper,lowerで各パラメータの上限指定
#log(0.000001),log(0.1)を指定するとエラーになる場合直接-13.8,-2.3を指定
fit.3<-dlmMLE(y,rep(0,7),build.3,hessian=T
              ,control = list(maxit = 1000,trace=1))

fit.3$convergence
fit.3$par
exp(fit.3$par)
fit.3$value 
```

Build model using the estimated var

```{r}
mod3 <- build.3(fit.3$par)
filt3<-dlmFilter(y,mod3)
smooth3 <- dlmSmooth(filt3)

a1<-dropFirst(smooth3$s[,1])
a2<-dropFirst(smooth3$s[,2]) #Morning
a3<-dropFirst(smooth3$s[,3]) #Noon
a4<-dropFirst(smooth3$s[,4]) #Evening
a5<-dropFirst(smooth3$s[,5]) #Prime
a6<-dropFirst(smooth3$s[,6]) #Midnight
estimatedLevel <- a0+x1*a1+x2*a2+x3*a3+x4*a4+x5*a5
plot(y, type="l", col=8, ylab="", main="Filtered Result")
lines(filt3$f,type="l",col=2)
lines(estimatedLevel,type="l",col=4)

par(mfrow=c(2,3)) 
plot(a1,type="l",xlab="days",ylab="beta_0" )
plot(a2,type="l",xlab="days",ylab="beta_1")
plot(a3,type="l",xlab="days",ylab="beta_2")
plot(a4,type="l",xlab="days",ylab="beta_3")
plot(a5,type="l",xlab="days",ylab="beta_4")
plot(a6,type="l",xlab="days",ylab="beta_5")

```


##Genreごとに集計


```{r}
grp$Genre<-gsub("(Cooking|Travel|Trava|Shopping|Local)", "Informative", grp$Genre)
grp$Genre<-gsub("(Movie|Anime)", "Drama", grp$Genre)
grp$Genre<-gsub("(Music|Documentary|undefined|'')", "Variety", grp$Genre)
g<- grp %>%
  dplyr::select(date,Genre,person) %>%
  dplyr::group_by(date=as.Date(date),genre=Genre) %>%
  dplyr::summarise(grp = sum(person)) %>%
  tidyr::spread(key = genre, value = grp)
g[is.na(g)]<-0
#視聴率と検索を結合
d <- dplyr::inner_join(q,g,by="date")
y<-log(d$query)
x1<-log(d$Drama+1)
x2<-log(d$Informative+1)
x3<-log(d$News+1)
x4<-log(d$Sports+1)
x5<-log(d$Variety+1)
vars<-cbind(x1,x2,x3,x4,x5)

build.4 <- function(params){
  # exp(param[1])の対数変換した空間で線形探索（山登り方で負の値もとらせるため）
  dlmModReg(vars,dV = exp(params[1]), dW = exp(params[2:7]))
}

fit.4<-dlmMLE(y,parm=rep(0,7),build=build.4
              ,lower = c(rep(-13.8,7))
              ,upper = c(rep(-2.3,7)),hessian=T
              ,control = list(maxit = 1000,trace=1))

fit.4$convergence
fit.4$par
exp(fit.4$par)
fit.4$value 

# Build model using the estimated var
mod4 <- build.4(fit.4$par)
filt4<-dlmFilter(y,mod4)
smooth4 <- dlmSmooth(mod4)

a1<-dropFirst(smooth4$s[,1])
a2<-dropFirst(smooth4$s[,2]) #Morning
a3<-dropFirst(smooth4$s[,3]) #Noon
a4<-dropFirst(smooth4$s[,4]) #Evening
a5<-dropFirst(smooth4$s[,5]) #Prime
a6<-dropFirst(smooth4$s[,6]) #Midnight
estimatedLevel <- a0+x1*a1+x2*a2+x3*a3+x4*a4+x5*a5
plot(y, type="l", col=8, ylab="", main="Filtered Result")
lines(filt4$f,type="l",col=2)
lines(estimatedLevel,type="l",col=4)
```

```{r}
#AIC
-2*fit.1$value+2*3 #単純集計
-2*fit.2$value+2*7 #Network
-2*fit.3$value+2*7 #時間帯
-2*fit.4$value+2*7 #ジャンル

```


Mazda(時間帯)
[1] 1209.443
[1] 1118.573
[1] 567.2308
[1] 1132.517

Suzuki(時間帯)
[1] 816.6708
[1] 745.4678
[1] 737.8359
[1] 741.6222

Nissan(局)
[1] 1026.343
[1] 935.1094
[1] 940.6592
[1] 961.1829

Honda(局)
[1] 1396.388
[1] 1306.174
[1] 1319.015
[1] 1318.604

Toyota(局)
[1] 1145.302
[1] 1049.063
[1] 1058.518
[1] 1055.797
